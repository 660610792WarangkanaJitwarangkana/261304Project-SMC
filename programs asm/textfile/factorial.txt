Program: Factorial (recursive version - simplified)
อธิบาย:
    - โปรแกรมนี้คำนวณค่า factorial ของจำนวน n (n!)
    - โดยใช้โครงสร้างการเรียกซ้ำ (recursion) ด้วยคำสั่ง jalr
    - แต่ใช้การบวกซ้ำ (simplified multiply) แทนการคูณจริง

Registers used:
    - r0 = constant 0 (always 0)
    - r1 = n (input parameter)
    - r2 = temp (-1 หรือ factorial(n-1))
    - r3 = result (ผลลัพธ์ factorial(n))
    - r6 = return address (สำหรับ jalr)
    - r7 = function address (ตำแหน่งของฟังก์ชัน fact)

main    lw      0   1   N       ; [r1 ← memory[N]] โหลดค่าของ n เข้าสู่ r1
                                ; ตัวเลข n จะเป็น input เริ่มต้นของ factorial

        jalr    6   7           ; [r6 ← PC+1, PC ← r7]
                                ; กระโดดไปยัง label 'fact'
                                ; พร้อมเก็บตำแหน่งกลับ (return address) ไว้ใน r6

        halt                    ; หยุดการทำงานของโปรแกรมหลัง factorial เสร็จสิ้น
                                ; เพื่อป้องกัน simulator รันต่อเกินหน่วยความจำ

Function: fact
    - คำนวณ factorial โดยโครงสร้าง recursion:
    - factorial(n) = 1 
    ถ้า n = 0
    n + fact(n-1) (ในที่นี้ใช้บวกแทนคูณ เพื่อความง่าย)

fact    beq     1   0   base    ; ถ้า r1 == 0 → กระโดดไปยัง base case
                                ; ตรวจสอบกรณี n = 0

        lw      0   2   NEG1    ; โหลดค่า -1 เข้าสู่ r2
                                ; ใช้สำหรับลดค่า n ลง 1

        add     1   2   1       ; r1 = r1 + (-1)
                                ; ลดค่า n ลง 1 → เตรียมเรียก factorial(n-1)

        jalr    6   7           ; เรียกฟังก์ชัน fact อีกครั้ง (recursive call)
                                ; บันทึกตำแหน่งกลับใหม่ใน r6

        lw      0   1   N       ; โหลดค่า n ต้นฉบับกลับมา (restore)
                                ; เพื่อใช้รวมผลภายหลัง (เพราะใน recursion ถูกลดลงไปแล้ว)

        lw      0   2   TMP     ; โหลดค่าผลลัพธ์ factorial(n-1) เข้าสู่ r2
                                ; TMP ใช้เก็บค่าชั่วคราวจากการเรียกก่อนหน้า

        add     3   2   3       ; r3 = r3 + r2
                                ; รวมผล factorial(n-1) + n (เป็นเวอร์ชันบวกจำลองการคูณ)
                                ; หากต้องการ factorial จริงควรเปลี่ยนเป็นการคูณ

        beq     0   0   end     ; กระโดดไปยังจุดสิ้นสุดของฟังก์ชัน fact
                                ; เพื่อ return กลับไปยัง main

Base case: ถ้า n = 0 → factorial(0) = 1
base    add     0   0   3       ; r3 = 1
                                ; base case ของ factorial = 1

End of function: return to caller
end     jalr    7   6           ; [PC ← r6]
                                ; กลับไปยังตำแหน่งที่เรียกฟังก์ชัน (main)

        noop                    ; คำสั่งว่าง เพื่อป้องกันการอ่าน memory ผิดตำแหน่ง
        halt                    ; หยุดการทำงานของ simulator (safety stop)


Data section
N       .fill   3               ; ค่าของ n (input) = 3
                                ; สามารถเปลี่ยนเป็นค่าทดสอบอื่นได้ (0–8)

NEG1    .fill   -1              ; ค่าคงที่ -1 สำหรับการลดค่า n
TMP     .fill   0               ; ตำแหน่งเก็บผลชั่วคราวจาก recursive call

หมายเหตุสำคัญ:

Mapping นี้อาศัยลำดับคำสั่งจาก factorial.asm ที่คุณให้ — หาก assembler ของเพื่อนมีวิธี resolve label (เช่น ใส่ address ที่ต่างกัน) ค่าใน .mc อาจเปลี่ยนได้ — แต่ concept การจับคู่คำสั่งกับค่าตัวเลขที่ .mc แสดงคือสิ่งที่ simulator ต้องเข้าใจ

Simulator ต้องสามารถ decode opcode และ fields จากเลขแต่ละบรรทัดตาม spec ที่เราเคยกำหนดไว้ (opcode: bits 24–22, rs:21–19, rt:18–16, imm/rd:15–0)