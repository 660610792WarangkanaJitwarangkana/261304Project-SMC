อธิบายทีละบรรทัด (บรรทัดเริ่มที่ 0):

Line 0: 2097163
    ตรงกับ lw 0 1 N (บรรทัดแรกใน factorial.asm)
    ความหมาย: โหลดค่าที่ address ของ label N ลงใน r1
    สรุป: r1 = mem[N]

Line 1: 5242887
    ตรงกับ jalr 6 7
    ความหมาย: call function — เก็บ PC+1 ลง r6 แล้วกระโดดไปที่ address ใน r7
    สังเกต: simulator ต้องตีความ 5242887 เป็น opcode ของ jalr และ rs/rd ตาม field

Line 2: 6291456
    ตรงกับ halt
    ความหมาย: หยุดการทำงาน

Line 3: 8396804
    ตรงกับ beq 1 0 base
    ความหมาย: ถ้า r1 == r0 ให้ jump ไปที่ label base

Line 4: 2097164
    ตรงกับ lw 0 2 NEG1
    ความหมาย: โหลดค่า -1 ลง r2

Line 5: 655361
    ตรงกับ add 1 2 1 (n = n - 1)
    ความหมาย: r1 = r1 + r2

Line 6: 5242887
    ตรงกับ jalr 6 7 (recursive call อีกครั้ง)
    ความหมาย: call recursive

Line 7: 2097163
    ตรงกับ lw 0 1 N (restore n)
    ความหมาย: โหลด n กลับจาก memory

Line 8: 2097165
    ตรงกับ lw 0 2 TMP (load temporary result)
    ความหมาย: r2 = mem[TMP] (สมมติ recursive store ผลที่ TMP)

Line 9: 655371
    ตรงกับ add 3 2 3 (result combine)
    ความหมาย: r3 = r3 + r2

Line 10: 4194304
    ตรงกับ beq 0 0 end (unconditional branch)
    ความหมาย: jump ไปที่ end (PC += 1 + offset); offset ต้อง match ให้ไปถึง end

Line 11: 3
    ตรงกับ .fill 3 (label N) — ค่าเริ่มต้น n = 3

Line 12: -1
    ตรงกับ .fill -1 (label NEG1)

Line 13: 0
    ตรงกับ .fill 0 (label TMP initial)

***หมายเหตุ:

Mapping นี้อาศัยลำดับคำสั่งจาก factorial.asm
— หาก assembler ของเพื่อนมีวิธี resolve label (เช่น ใส่ address ที่ต่างกัน) ค่าใน .mc อาจเปลี่ยนได้
— แต่ concept การจับคู่คำสั่งกับค่าตัวเลขที่ .mc แสดงคือสิ่งที่ simulator ต้องเข้าใจ

Simulator ต้องสามารถ decode opcode และ fields จากเลขแต่ละบรรทัดตาม spec ที่เคยกำหนดไว้
(opcode: bits 24–22, rs:21–19, rt:18–16, imm/rd:15–0)